using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Google.PhoneNumbers.GenerateData
{
    public class BuildMetadataProtoFromXml
    {
        private static readonly String CLASS_NAME = typeof (BuildMetadataProtoFromXml).Name;
//        private static readonly String PACKAGE_NAME = typeof (BuildMetadataProtoFromXml).FullName;

        // Command line parameter names.
        private const String INPUT_FILE = "input-file";
        private const String OUTPUT_DIR = "output-dir";
        private const String DATA_PREFIX = "data-prefix";
        private const String MAPPING_CLASS = "mapping-class";
        private const String COPYRIGHT = "copyright";
        private const String LITE_BUILD = "lite-build";

        private static readonly String HELP_MESSAGE =
            "Usage: " + CLASS_NAME + " [OPTION]...\n" +
            "\n" +
            "  --" + INPUT_FILE + "=PATH     Read phone number metadata in XML format from PATH.\n" +
            "  --" + OUTPUT_DIR + "=PATH     Use PATH as the root directory for output files.\n" +
            "  --" + DATA_PREFIX +
            "=PATH    Use PATH (relative to " + OUTPUT_DIR + ") as the basename when\n" +
            "                        writing phone number metadata (one file per region) in\n" +
            "                        proto format.\n" +
            "  --" + MAPPING_CLASS + "=NAME  Store country code mappings in the class NAME, which\n" +
            "                        will be written to a file in " + OUTPUT_DIR + ".\n" +
            "  --" + COPYRIGHT + "=YEAR      Use YEAR in generated copyright headers.\n" +
            "\n" +
            "  [--" + LITE_BUILD + "=<true|false>]  Optional (default: false). In a lite build,\n" +
            "                               certain metadata will be omitted. At this\n" +
            "                               moment, example numbers information is omitted.\n" +
            "\n" +
            "Example command line invocation:\n" +
            CLASS_NAME + " \\\n" +
            "  --" + INPUT_FILE + "=resources/PhoneNumberMetadata.xml \\\n" +
            "  --" + OUTPUT_DIR + "=java/libphonenumber/src/com/google/i18n/phonenumbers \\\n" +
            "  --" + DATA_PREFIX + "=data/PhoneNumberMetadataProto \\\n" +
            "  --" + MAPPING_CLASS + "=CountryCodeToRegionCodeMap \\\n" +
            "  --" + COPYRIGHT + "=2010 \\\n" +
            "  --" + LITE_BUILD + "=false\n";

        private static readonly String GENERATION_COMMENT =
            "/* This file is automatically generated by {@link " + CLASS_NAME + "}.\n" +
            " * Please don't modify it directly.\n" +
            " */\n\n";

        public static void Main(string[] args)
        {
            // The format of a well-formed command line parameter.
            var pattern = new Regex("--(.+?)=(.*)");

            String inputFile = null;
            String outputDir = null;
            String dataPrefix = null;
            String mappingClass = null;
            String copyright = null;
            bool liteBuild = false;

            for (int i = 0; i < args.Length; i++)
            {
                String key = null;
                String value = null;
                var matcher = pattern.Match(args[i]);
                if (matcher.Success)
                {
                    key = matcher.Groups[1].Value;
                    value = matcher.Groups[2].Value;
                }

                if (INPUT_FILE.Equals(key))
                {
                    inputFile = value;
                }
                else if (OUTPUT_DIR.Equals(key))
                {
                    outputDir = value;
                }
                else if (DATA_PREFIX.Equals(key))
                {
                    dataPrefix = value;
                }
                else if (MAPPING_CLASS.Equals(key))
                {
                    mappingClass = value;
                }
                else if (COPYRIGHT.Equals(key))
                {
                    copyright = value;
                }
                else if (LITE_BUILD.Equals(key) &&
                         ("true".Equals(value, StringComparison.OrdinalIgnoreCase) ||
                          "false".Equals(value, StringComparison.OrdinalIgnoreCase)))
                {
                    liteBuild = "true".Equals(value, StringComparison.OrdinalIgnoreCase);
                }
                else
                {
                    Console.WriteLine(HELP_MESSAGE);
                    Console.WriteLine("Illegal command line parameter: " + args[i]);
                    return;
                }
            }

            if (inputFile == null ||
                outputDir == null ||
                dataPrefix == null ||
                mappingClass == null ||
                copyright == null)
            {
                Console.WriteLine(HELP_MESSAGE);
                return;
            }


            String filePrefix = Path.Combine(outputDir, dataPrefix);

            try
            {
                PhoneMetadataCollection metadataCollection =
                    BuildMetadataFromXml.buildPhoneMetadataCollection(inputFile, liteBuild);

                foreach (PhoneMetadata metadata in metadataCollection.getMetadataList())
                {
                    String regionCode = metadata.getId();
                    // For non-geographical country calling codes (e.g. +800), or for alternate formats, use the
                    // country calling codes instead of the region code to form the file name.
                    if (regionCode.Equals("001") || String.IsNullOrEmpty(regionCode))
                    {
                        regionCode = metadata.getCountryCode().ToString();
                    }
                    PhoneMetadataCollection outMetadataCollection = new PhoneMetadataCollection();
                    outMetadataCollection.addMetadata(metadata);
                    using (var outputForRegion = new FileStream(filePrefix + "_" + regionCode, FileMode.OpenOrCreate))
                    {
                        outputForRegion.SetLength(0);
                        using (var writer = new BinaryWriter(outputForRegion))
                        {
                            outMetadataCollection.writeExternal(writer);
                        }
                    }
                }

                Dictionary<int, List<String>> countryCodeToRegionCodeMap =
                    BuildMetadataFromXml.buildCountryCodeToRegionCodeMap(metadataCollection);
//
                writeCountryCallingCodeMappingToCSharpFile(countryCodeToRegionCodeMap, outputDir, mappingClass,
                    copyright);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.ToString());
                return;
            }
            Console.WriteLine("Metadata code successfully generated.");
        }

        private const String MAP_COMMENT =
            "  // A mapping from a country code to the region codes which denote the\n" +
            "  // country/region represented by that country code. In the case of multiple\n" +
            "  // countries sharing a calling code, such as the NANPA countries, the one\n" +
            "  // indicated with \"isMainCountryForCode\" in the metadata should be first.\n";

        private const String COUNTRY_CODE_SET_COMMENT =
            "  // A set of all country codes for which data is available.\n";

        private const String REGION_CODE_SET_COMMENT =
            "  // A set of all region codes for which data is available.\n";

        private const double CAPACITY_FACTOR = 0.75;

        private static readonly String CAPACITY_COMMENT =
            "    // The capacity is set to %d as there are %d different entries,\n" +
            "    // and this offers a load factor of roughly " + CAPACITY_FACTOR + ".\n";

        private static void writeCountryCallingCodeMappingToCSharpFile(
            Dictionary<int, List<String>> countryCodeToRegionCodeMap,
            String outputDir, String mappingClass, String copyright)
        {
            // Find out whether the countryCodeToRegionCodeMap has any region codes or country
            // calling codes listed in it.
            bool hasRegionCodes = false;
            foreach (List<String> listWithRegionCode in countryCodeToRegionCodeMap.Values)
            {
                if (listWithRegionCode.Count != 0)
                {
                    hasRegionCodes = true;
                    break;
                }
            }
            bool hasCountryCodes = countryCodeToRegionCodeMap.Count > 1;

            ClassWriter writer = new ClassWriter(outputDir, mappingClass, copyright);

            int capacity = (int) (countryCodeToRegionCodeMap.Count/CAPACITY_FACTOR);
            if (hasRegionCodes && hasCountryCodes)
            {
                writeMap(writer, capacity, countryCodeToRegionCodeMap);
            }
            else if (hasCountryCodes)
            {
                writeCountryCodeSet(writer, capacity, countryCodeToRegionCodeMap);
            }
            else
            {
                List<String> regionCodeList = countryCodeToRegionCodeMap[0];
                capacity = (int) (regionCodeList.Count/CAPACITY_FACTOR);
                writeRegionCodeSet(writer, capacity, regionCodeList);
            }

            writer.writeToFile();
        }

        private static void writeMap(ClassWriter writer, int capacity,
            Dictionary<int, List<String>> countryCodeToRegionCodeMap)
        {
            writer.addToBody(MAP_COMMENT);

            writer.addToImports("System");
            writer.addToImports("System.Collections.Generic");

            writer.addToBody("  internal static Dictionary<int, List<String>> getCountryCodeToRegionCodeMap() {\n");
            writer.formatToBody(CAPACITY_COMMENT, capacity, countryCodeToRegionCodeMap.Count);
            writer.addToBody("    Dictionary<int, List<String>> countryCodeToRegionCodeMap =\n");
            writer.addToBody("        new Dictionary<int, List<String>>(" + capacity + ");\n");
            writer.addToBody("\n");
            writer.addToBody("    List<String> listWithRegionCode;\n");
            writer.addToBody("\n");

            foreach (var entry in countryCodeToRegionCodeMap)
            {
                int countryCallingCode = entry.Key;
                List<String> regionCodes = entry.Value;
                writer.addToBody("    listWithRegionCode = new List<String>(" +
                                 regionCodes.Count + ");\n");
                foreach (String regionCode in regionCodes)
                {
                    writer.addToBody("    listWithRegionCode.Add(\"" + regionCode + "\");\n");
                }
                writer.addToBody("    countryCodeToRegionCodeMap.Add(" + countryCallingCode +
                                 ", listWithRegionCode);\n");
                writer.addToBody("\n");
            }

            writer.addToBody("    return countryCodeToRegionCodeMap;\n");
            writer.addToBody("  }\n");
        }

        private static void writeRegionCodeSet(ClassWriter writer, int capacity,
            List<String> regionCodeList)
        {
            writer.addToBody(REGION_CODE_SET_COMMENT);

            writer.addToImports("System");
            writer.addToImports("System.Collections.Generic");

            writer.addToBody("  internal static ISet<String> getRegionCodeSet() {\n");
            writer.formatToBody(CAPACITY_COMMENT, capacity, regionCodeList.Count);
            writer.addToBody("    ISet<String> regionCodeSet = new HashSet<String>();\n");
            writer.addToBody("\n");

            foreach (String regionCode in regionCodeList)
            {
                writer.addToBody("    regionCodeSet.Add(\"" + regionCode + "\");\n");
            }

            writer.addToBody("\n");
            writer.addToBody("    return regionCodeSet;\n");
            writer.addToBody("  }\n");
        }

        private static void writeCountryCodeSet(ClassWriter writer, int capacity,
            Dictionary<int, List<string>> countryCodeSet)
        {
            writer.addToBody(COUNTRY_CODE_SET_COMMENT);

            writer.addToImports("System.Collections.Generic");

            writer.addToBody("  internal static ISet<int> getCountryCodeSet() {\n");
            writer.formatToBody(CAPACITY_COMMENT, capacity, countryCodeSet.Count);
            writer.addToBody("    ISet<int> countryCodeSet = new HashSet<int>();\n");
            writer.addToBody("\n");

            foreach (int countryCallingCode in countryCodeSet.Keys)
            {
                writer.addToBody("    countryCodeSet.Add(" + countryCallingCode + ");\n");
            }

            writer.addToBody("\n");
            writer.addToBody("    return countryCodeSet;\n");
            writer.addToBody("  }\n");
        }

        private class ClassWriter
        {
            private readonly String name;
            private readonly String copyright;

            private readonly SortedSet<String> imports;
            private readonly StringBuilder body;
            private readonly StreamWriter writer;

            internal ClassWriter(String outputDir, String name, String copyright)
            {
                this.name = name;
                this.copyright = copyright;

                imports = new SortedSet<String>();
                body = new StringBuilder();
                var path = Path.Combine(outputDir, name + ".cs");
                var stream = new FileStream(path, FileMode.OpenOrCreate);
                stream.SetLength(0);
                writer = new StreamWriter(stream);
            }

            internal void addToImports(String name)
            {
                imports.Add(name);
            }

            internal void addToBody(string text)
            {
                body.Append(text);
            }

            internal void formatToBody(String format, params object[] args)
            {
                body.AppendFormat(format, args);
            }

            internal void writeToFile()
            {
                CopyrightNotice.writeTo(writer, copyright);
                writer.Write(GENERATION_COMMENT);
                writer.Write("namespace Google.PhoneNumbers {\n\n");

                if (imports.Count != 0)
                {
                    foreach (String item in imports)
                    {
                        writer.Write("using " + item + ";\n");
                    }
                    writer.Write("\n");
                }

                writer.Write("public class " + name + " {\n");
                writer.Write(body.ToString());
                writer.Write("}\n");
                writer.Write("}\n");

                writer.Flush();
                writer.Close();
            }
        }
    }
}